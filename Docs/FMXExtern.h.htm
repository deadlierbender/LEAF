<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html slick-uniqueid="3" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-gb" dir="ltr" lang="en-gb"><head>
<script src="FMXExtern.h_files/ga.js" async="" type="text/javascript"></script><script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-34699114-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
	  <!-- base href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxextern-h" -->
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="keywords" content="productie, podiumkunsten, cultuur, cultuursector, copywriter, teksten, tekstschrijver, programmatoelichting, programmaboek, redactie, redacteur,planning, concerten, festivals, subsidieaanvragen, ensembles, Filemaker sdk headers, filemaker, sdk, filemaker api, api, plug-ins, plug-in, filemaker plug-in, filemaker plug-ins, ">
  <meta name="author" content="Super User">
  <meta name="description" content="Van der Linden Cultural Services levert diensten in de cultuursector. U kunt terecht voor teksten (zakelijk en informatief), productie en stage management in de podiumkunsten, Filemaker-database-development, transport, etc.">
  <meta name="generator" content="Joomla! - Open Source Content Management">
  <title>Van der Linden Cultural Services - FMXExtern.h</title>
  <link href="http://culturalservices.nl/index.php/component/search/?Itemid=532&amp;format=opensearch" rel="search" title="Search Van der Linden Cultural Services" type="application/opensearchdescription+xml">
  <link rel="stylesheet" href="FMXExtern.h_files/highslide.css" type="text/css">
  <link rel="stylesheet" href="FMXExtern.h_files/highslide-sitestyles.css" type="text/css">
  <link rel="stylesheet" href="FMXExtern.h_files/shCoreEclipse.css" type="text/css">
  <link rel="stylesheet" href="FMXExtern.h_files/shThemeEclipse.css" type="text/css">
  <script src="FMXExtern.h_files/mootools-core.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/core.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/caption.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/highslide-full.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/easing_equations.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/swfobject.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/en.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/highslide-sitesettings.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shCore.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushCpp.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushCSharp.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushCss.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushJava.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushJScript.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushPhp.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushPlain.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/shBrushXml.js" type="text/javascript"></script>
  <script src="FMXExtern.h_files/mootools-more.js" type="text/javascript"></script>
  <script type="text/javascript">
window.addEvent('load', function() {
				new JCaption('img.caption');
			});
hs.graphicsDir = '/plugins/content/highslide/graphics/';

			  SyntaxHighlighter.all();
		 
  </script>

	<!-- The following line loads the template CSS file located in the template folder. -->
	<link rel="stylesheet" href="FMXExtern.h_files/template.css" type="text/css">
<style type="text/css">.highslide img {cursor: url(/plugins/content/highslide/graphics/zmin.cur), pointer !important;}.highslide-viewport-size {position: fixed; width: 100%; height: 100%; left: 0; top: 0}</style></head>
<body id="page_bg">

	<div class="top-menu">
		<div id="sgmenu">
			
		</div>
	</div>

	<div id="mainwrap">
	<div id="header">
	

	
	
		<div id="search">
			<form action="/index.php/filemaker-plug-ins/fmxextern-h" method="post">
	<div class="search">
		<label for="mod-search-searchword">Search...</label><input name="searchword" id="mod-search-searchword" maxlength="20" class="inputbox" size="20" value="Search..." onblur="if (this.value=='') this.value='Search...';" onfocus="if (this.value=='Search...') this.value='';" type="text">	<input name="task" value="search" type="hidden">
	<input name="option" value="com_search" type="hidden">
	<input name="Itemid" value="532" type="hidden">
	</div>
</form>

		</div>
	
		<h1><a href="http://www.culturalservices.nl/index.php/filemaker-plug-ins">Filemaker Plug-Ins</a></h1>					
		
	</div>
	<div id="wrapper">
		<div id="content_m">
						<div class="maincol_w_left">
						
									<div class="leftcol">
								<div class="module">
			<div>
				<div>
					<div>
													<h3>Filemaker</h3>
											








<ul class="menu">




<li id="item-535" class="active parent"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins"><span>Filemaker SDK headers</span></a><ul><li id="item-532" class="current active"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxextern-h"><span>FMXExtern.h</span></a></li><li id="item-537"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxclient-h"><span>FMXClient.h</span></a></li><li id="item-538"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/datetime-h"><span>FMXDateTime.h</span></a></li><li id="item-539"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxfixpt-h"><span>FMXFixPt.h</span></a></li><li id="item-540"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxtextstyle-h"><span>FMXTextStyle.h</span></a></li><li id="item-542"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxtypes-h"><span>FMXTypes.h</span></a></li><li id="item-545"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxbinarydata-h"><span>FMXBinaryData.h</span></a></li><li id="item-546"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxtext-h"><span>FMXText.h</span></a></li><li id="item-543"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxdata-h"><span>FMXData.h</span></a></li><li id="item-544"><a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxcalcengine-h"><span>FMXCalcEngine.h</span></a></li></ul></li><li id="item-536"><a href="http://culturalservices.nl/index.php/resources"><span>Resources</span></a></li></ul>					</div>
				</div>
			</div>
		</div>
	
					</div>
					
						<div class="cont">
							<div class="item-page">

	<h2>
			<a href="http://culturalservices.nl/index.php/filemaker-plug-ins/fmxextern-h">
		FMXExtern.h</a>
		</h2>








<p>The FMXExtern.h header contains the following.</p>
<h3>Platform specific macros</h3>
<p>The FMXExtern.h header starts with separating the different 
implications for GCC- and Visual C++-compilers in several macros. These 
are:</p>
<div><div id="highlighter_181722" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">( __GNUC__ )</code></div><div class="line number2 index1 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __attribute__ ((packed))</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK_ON</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK_OFF</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PROC(retType)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retType</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PROCPTR(retType, name)&nbsp; </code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">retType (*name)</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_ENTRYPT</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_API</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_AUTOPTRRESET(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reset(x)</code></div><div class="line number10 index9 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">elif</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">( _MSC_VER )</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK_ON&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pack (push, 1)</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PACK_OFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pack (pop)</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PROC(retType)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; retType </code><code class="cpp keyword bold">__stdcall</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_PROCPTR(retType, name)&nbsp; </code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">retType (</code><code class="cpp keyword bold">__stdcall</code> <code class="cpp plain">*name)</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_ENTRYPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp keyword bold">__declspec</code><code class="cpp plain">(</code><code class="cpp keyword bold">dllexport</code><code class="cpp plain">)</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_API&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp keyword bold">__declspec</code><code class="cpp plain">(</code><code class="cpp keyword bold">dllimport</code><code class="cpp plain">)</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_AUTOPTRRESET(x)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp keyword bold">this</code><code class="cpp plain">-&gt;operator=(*</code><code class="cpp keyword bold">static_cast</code><code class="cpp plain">&lt;UpCaster*&gt;(&amp;std::auto_ptr&lt;element_type&gt;(x)))</code></div><div class="line number19 index18 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">else</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">error</code> <code class="cpp string">"Unexpected compiler"</code></div><div class="line number21 index20 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div></div></td></tr></tbody></table></div></div>
<p>Depending on whether you are compiling on Mac or on Windows these 
macros will have different definitions. If you compile on Mac OS X, you 
will have to use a GNU C++ Compiler (GCC, which is one of the compilers 
that comes with the XCode suite). When you are using this compiler, it 
defines the macro <code>
__GNUC_</code>. The&nbsp;<code>
#ifdef __GNUC_
</code> preprocessor directive checks if this is the case and if so, it 
compiles the code immediately following it. On Microsoft-based computers
 you could use the Visual C++-compiler (shipping with Visual Studio) 
which usage is detected with<code>
#ifdef _MSC_VER
</code> (meaning that a MicroSoft visual C++ compiler VERsion is defined
 somewhere by the compiler). (Or you could use a Windows- version of the
 GNU C++ Compiler.) If none of these are compiling this code, the 
preprocessor will give you the error “Unexpected compiler”. Although 
strictly speaking you could compile with a GCC-compiler on Windows, you 
should not do so. The macros <code>__GNUC_
</code> and&nbsp;<code>_MSC_VER
</code> are therefore “platform specific macros”. The first is for 
compiling on MAC OS X, the other for compiling on Windows. Whenever you 
read “GCC-compiler” below, you can replace that by “the compiler on MAC 
OS X” and the same goes for the “Visual C++-compiler”, which means the 
“compiler on Windows”.</p>
<p>All of the above macros and their different definitions are explained in detail below.</p>
<h3>FMX_PACK, FMX_PACK_ON and FMX_PACK_OFF</h3>
<p>The <code class="brush:cpp">
FMX_PACK</code>, <code class="brush:cpp">
FMX_PACK_ON
</code>and<code class="brush:cpp">
FMX_PACK_OFF
</code> macros are used only in the FMXExtern.h header file. <code class="brush:cpp">
FMX_PACK </code>is defined for GNU C++ Compilers as <code class="brush:cpp">
__attribute__ ((packed))</code>. This tells the compiler to “pack” the 
number of bytes used in a struct or union to the minimum (in this case 
1) required. Because the output is a plugin that should communicate with
 Filemaker, the methods used to communicate must match between plug-in 
and Filemaker. These macros make sure that this is the case.</p>
<p>A character uses 4 bytes, even if it is just one byte and 3 empty 
bytes. This is because compilers like to speed up things and use 4 bytes
 all the time. If the <code class="brush:cpp">
__attribute__ ((packed))
</code>statement is used with a struct, the GCC-compiler knows it should
 just use the filled byte and not use the empty byte. So, a character (1
 byte) and an int (4 bytes) will make a struct of 8 bytes if it is not 
packed and a struct of 5 bytes if it is packed.</p>
<p>The&nbsp;<code class="brush:cpp">__attribute__ ((packed))
</code> statement doesn’t work on the Visual C++-compiler; that’s why 
the macro is defined as nothing for MSC. Otherwise it would tell you it 
encountered a mistake. The Visual C++-Compiler does have an equivalent 
to pack the data in a struct. That is <code class="brush:cpp">
#pragma pack(push,1)</code>. This statement tells the compiler that the 
structs that follow this pragma-directive will all have to packed 
variables to the minimum of 1, if possible. (The push parameter tells 
the compiler to save the current pack alignment; the saved alignment 
will be reinstated by using <code class="brush:cpp">
pack(pop)</code>.) A character of one byte and three empty bytes will be
 packed to one byte. An int of four bytes will stay four bytes. Both 
the&nbsp;<code class="brush:cpp">
__attribute__ ((packed))
</code> and the&nbsp;<code class="brush:cpp">
pack(push,1)
</code> statement ensure that on both compilers the same space is taken 
by the struct in consideration. This, in turn, ensures that the Mac- and
 Windows-versions of Filemaker have the same struct packing as the 
plug-ins on both platforms. Because the&nbsp;<code class="brush:cpp">__attribute__ ((packed))
</code> only applies to one struct, and the <code class="brush:cpp">
pack(push,1)</code> applies to all following structs, the latter has to be disabled immediately after defining a struct. That’s where the&nbsp;<code class="brush:cpp">FMX_PACK_OFF
</code> macro comes in. It is defined (only for the Visual C++-compiler)
 as pack(pop). This means that the packing alignment to be used for 
structs and union following&nbsp;<code class="brush:cpp">
#pragma pack(pop)
</code> should use the latest packing alignment that was added using <code class="brush:cpp">
#pragma pack(push)</code>, restoring the packing method used before <code class="brush:cpp">
FMX_PACK_ON</code>.</p>
<p>The three macros discussed so far are used once in the FMXExtern.h header, i.e. in defining a struct called <code class="brush:cpp">
FMX_ExternCallStruct</code>:</p>
<div><div id="highlighter_152072" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#pragma FMX_PACK_ON</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">struct</code> <code class="cpp plain">FMX_ExternCallStruct</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//struct function pointers and variables</code></div><div class="line number5 index4 alt2"><code class="cpp plain">} FMX_PACK;</code></div><div class="line number6 index5 alt1"><code class="cpp plain">#pragma FMX_PACK_OFF</code></div></div></td></tr></tbody></table></div></div>
<p>For the GCC-compiler (where __GNUC_ is defined), this translates to:</p>
<div><div id="highlighter_543460" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#pragma</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">struct</code> <code class="cpp plain">FMX_ExternCallStruct</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//struct functions and variables</code></div><div class="line number5 index4 alt2"><code class="cpp plain">} __attribute__ ((packed));</code></div><div class="line number6 index5 alt1"><code class="cpp plain">#pragma</code></div></div></td></tr></tbody></table></div></div>
<p>If the Visual C++-compiler encounters it, it will enable packing 
before the struct and restore the packing alignment after the struct:</p>
<div><div id="highlighter_897656" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#pragma pack (push, 1)</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">struct</code> <code class="cpp plain">FMX_ExternCallStruct</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//struct functions and variables</code></div><div class="line number5 index4 alt2"><code class="cpp plain">};</code></div><div class="line number6 index5 alt1"><code class="cpp plain">#pragma pack (pop)</code></div></div></td></tr></tbody></table></div></div>
<h3>FMX_PROC(retType)</h3>
<p>The difference between the definitions of this macro is that for the Visual C++-compiler the statement&nbsp;<code class="brush:cpp">__stdcall
</code> is added. But first we’ll have at look at how the macro is used.
 As you might have guessed, the retType in the macro and its definition 
means return type. Say, a normal function returns an int:</p>
<div><div id="highlighter_158193" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">Function()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp color1 bold">int</code> <code class="cpp plain">a = 1;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">return</code> <code class="cpp plain">a;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>If we use the macro as the return type we’ll get this:</p>
<div><div id="highlighter_705967" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROC(</code><code class="cpp color1 bold">int</code><code class="cpp plain">) Function()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp color1 bold">int</code> <code class="cpp plain">a = 1;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">return</code> <code class="cpp plain">a;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>For the GCC-compiler this macro is substituted by the argument passed
 to the macro, so the int is substituted by int, which would amount to 
exactly the same function as the first:</p>
<div><div id="highlighter_756347" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">Function()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp color1 bold">int</code> <code class="cpp plain">a = 1;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">return</code> <code class="cpp plain">a;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>The Visual C++-compiler is instructed to substitute the macro for the argument passed to it AND an additional <code class="brush:cpp">
__stdcall</code>. So we would get this function.</p>
<div><div id="highlighter_11800" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp keyword bold">__stdcall</code> <code class="cpp plain">Function()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp color1 bold">int</code> <code class="cpp plain">a = 1;</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">return</code> <code class="cpp plain">a;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>Why is the&nbsp;<code class="brush:cpp">__stdcall
</code> added here and not when using the GCC-compiler? The simpler answer would be:&nbsp;<code class="brush:cpp">__stdcall
</code> is supported by Microsoft-environments (and therefore supported 
by the Visual C++-compiler), whereas it is not supported by Mac OS X (on
 which you should use the GCC-compiler). The more complicated answer is 
that <code class="brush:cpp">
__stdcall
</code>is the STanDard CALLing convention that you can specify for 
function. It specifies that a function should be called using the 
standard way of calling for the Microsoft Win32 API. Because a project 
on Windows can be built with different calling conventions, and 
Filemaker has to communicate with your plug-in’s functions using this 
same calling convention, it should be specified which calling 
conventions is used. Compiling code with GCC for Mac OS X, the compiler 
always uses the same calling convention. There is no need to specify it 
because both the Mac-version of Filemaker and the plug-in you create on 
Mac use the same calling convention. A calling convention describes the 
way arguments are passed to function, how it returns a return value and 
how the functions are “decorated”. A plug-in should use the same calling
 convention as the application that calls it, otherwise the plug-in 
function called from Filemaker will have a different setup than the 
actual function in the plug-in. Filemaker, it appears, uses the <code class="brush:cpp">
__stdcall
</code>convention to call plug-in functions when on Windows, so your 
plug-in needs to comply with that calling convention. Hence the need to 
explicitly specify <code class="brush:cpp">
__stdcall
</code>for those function that interact with Filemaker on Windows.</p>
<h3>FMX_PROCPTR(retType, name)</h3>
<p>Here we will discuss the constant part of this macro, which is <code class="brush:cpp">
typedef retType (*name)</code>. The non-constant part, <code class="brush:cpp">
__stdcall</code>, is discussed in the previous section.</p>
<p>The Filemaker plug-in you can build using the Filemaker plug-in SDK 
needs to call several Filemaker functions. To achieve this, the plug-in 
needs access to several functions within Filemaker.&nbsp;<code class="brush:cpp">FMX_PROCPTR()
</code> is part of the method your plug-in uses to gain this access to Filemaker functions.&nbsp;<code class="brush:cpp">FMX_PROCPTR(retType,name)
</code> is defined as&nbsp;<code class="brush:cpp">typedef retType (*name)</code>. <code class="brush:cpp">
typedef
</code>defines an alternative name for an existing type. In this case, the existing type is <code class="brush:cpp">
retType</code>, or rather, an existing type must be sent as the macro’s 
parameter. The alternative name should be send to the macro as well and a
 pointer to this alternative name is then type-defined using typedef. 
Using&nbsp;<code class="brush:cpp">int
</code> as an example the macro could be used as such:</p>
<div><div id="highlighter_915916" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp color1 bold">int</code><code class="cpp plain">,AlternativeIntPtr)</code></div></div></td></tr></tbody></table></div></div>
<p>This would do the following:</p>
<div><div id="highlighter_828406" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">int</code> <code class="cpp plain">(*AlternativeIntPtr)</code></div></div></td></tr></tbody></table></div></div>
<p>Now, instead of using:</p>
<div><div id="highlighter_792252" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 5;</code></div><div class="line number2 index1 alt1"><code class="cpp color1 bold">int</code> <code class="cpp plain">* a = &amp;i;</code></div></div></td></tr></tbody></table></div></div>
<p>one could write:</p>
<div><div id="highlighter_838588" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">i = 5;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">AlternativeIntPtr a = &amp;i;</code></div></div></td></tr></tbody></table></div></div>
<p>The&nbsp;<code class="brush:cpp">FMX_PROCPTR(retType, name)
</code> is used several times in this header (FMExtern.h) and once in 
the header FMXCalcEngine.h. The one in this latter has the following 
syntax:</p>
<div><div id="highlighter_977890" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROCPTR( errcode, ExtPluginType ) ( </code><code class="cpp color1 bold">short</code> <code class="cpp plain">functionId, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">ExprEnv&amp; env, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">DataVect&amp; parms, Data&amp; result );</code></div></div></td></tr></tbody></table></div></div>
<p>Substituting the macro for its definition we will get the following:</p>
<div><div id="highlighter_744935" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">errcode (*ExtPluginType) ( </code><code class="cpp color1 bold">short</code> <code class="cpp plain">functionId, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">ExprEnv&amp; env, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">DataVect&amp; parms, Data&amp; result );</code></div></div></td></tr></tbody></table></div></div>
<p>This is not simply a substitution of a type for a pointer to this 
type. This is one of the ways to create a function pointer. A clearer 
way to define a function pointer is thus:</p>
<div><div id="highlighter_494103" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">short</code> <code class="cpp plain">(*func_pointer) ( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">argument1, </code><code class="cpp color1 bold">int</code> <code class="cpp plain">argument2 </code><code class="cpp comments">/*etc.*/</code> <code class="cpp plain">);</code></div></div></td></tr></tbody></table></div></div>
<p>This looks like a regular function with the addition of an asterisk 
and two parentheses. The asterisk is there to make sure it points to the
 address of a function. (Functions, just like variables, have an 
address.) The parentheses need to be there to make sure the asterisk is 
linked to <code class="brush:cpp">
func_pointer 
</code>and not to the return type&nbsp;<code class="brush:cpp">short
</code> (otherwise it would mean: a regular function returning a short pointer). Using&nbsp;<code class="brush:cpp">typedef
</code> to define a function pointer is simply a method to create an 
easier to read, variable-like substitution. The function pointer is its 
return type when used in this way.</p>
<div><div id="highlighter_901270" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">short</code> <code class="cpp plain">(*func_pointer) ( </code><code class="cpp color1 bold">int</code> <code class="cpp plain">argument1, </code><code class="cpp color1 bold">int</code> <code class="cpp plain">argument2 </code><code class="cpp comments">/*etc.*/</code> <code class="cpp plain">);</code></div></div></td></tr></tbody></table></div></div>
<p>Right after this type definition we can do:</p>
<div><div id="highlighter_147315" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">func_pointer Foo;</code></div></div></td></tr></tbody></table></div></div>
<p><code class="brush:cpp">
Foo</code>&nbsp;now is a ready-to-use function pointer to which we can assign the address of a function (of the kind that&nbsp;<code class="brush:cpp">Foo</code>&nbsp;can point to). After that, we can either call the function at the address of&nbsp;<code class="brush:cpp">Foo</code> or use it as an argument in another function that takes a function pointer as an argument.</p>
<div><div id="highlighter_18588" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">Bar (Foo); </code><code class="cpp comments">//Function pointer Foo as an argument to a function</code></div></div></td></tr></tbody></table></div></div>
<p>(Now the function&nbsp;<code class="brush:cpp">Bar</code>&nbsp;is able to call the function at the address of<code class="brush:cpp">
Foo</code>.)</p>
<p>This is what we can do with <code class="brush:cpp">
ExtPluginType</code>. We use it as if it is a type and give it the 
address of a function; then we pass the function pointer to another 
function, for example to function&nbsp;<code class="brush:cpp">
RegisterExternalFunction
</code> (which is also in the FMXCalcEngine.h header).</p>
<div><div id="highlighter_889567" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">ExtPluginType ACertainPluginType; </code><code class="cpp comments">//use of the function pointer as a variable</code></div><div class="line number2 index1 alt1"><code class="cpp plain">ACertainPluginType = &amp;ACertainFunction; </code><code class="cpp comments">//give it the addres of an actual function</code></div><div class="line number3 index2 alt2"><code class="cpp plain">RegisterExternalFunction(</code><code class="cpp comments">/*several arguments*/</code><code class="cpp plain">, ACertainFuntion);</code><code class="cpp comments">//pass the address</code></div></div></td></tr></tbody></table></div></div>
<p>So,&nbsp;<code class="brush:cpp">ExtPluginType
</code> is a function pointer “type” that takes the parameters&nbsp;<code class="brush:cpp">functionID
</code> etc. and has the return type errcode.</p>
<div><div id="highlighter_876570" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">errcode (*Foo) ( </code><code class="cpp color1 bold">short</code> <code class="cpp plain">functionId, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">ExprEnv&amp; env, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">DataVect&amp; parms, Data&amp; result );</code></div></div></td></tr></tbody></table></div></div>
<p>Why do we need function pointers for our plug-in? The reason is that 
several functions in our plug-in need to be called by Filemaker (and the
 other way around). Filemaker wouldn’t know which function to call if it
 wouldn’t know anything about it. By passing a function pointer with the
 address of an actual function to Filemaker, we tell Filemaker “You can 
use the address of this function pointer to call me!”</p>
<h3>FMX_ENTRYPT and FMX_API</h3>
<p>The macros <code class="brush:cpp">
FMX_ENTRYPT
</code>(entry point) and <code class="brush:cpp">
FMX_API
</code>(Application Programming Interface) are not defined using a 
GCC-compiler. Compiling with GCC on Mac, everything in this header is 
public by default. This means that applications can access everything in
 the plug-in that has been compiled. For the Visual C++ compiler, 
however, these&nbsp;<code class="brush:cpp">FMX_ENTRYPT
</code> and <code class="brush:cpp">
FMX_API
</code>are defined as&nbsp;<code class="brush:cpp">__declspec(dllexport)
</code> and&nbsp;<code class="brush:cpp">__declspec(dllimport)
</code> respectively.&nbsp;<code class="brush:cpp">
__declspec
</code> is a declaration specifier. The dllexport and dllimport are storage-class attributes. Using&nbsp;<code class="brush:cpp">__declspec(dllexport)
</code> with a declaration specifies the declaration with the 
storage-class attribute dllexport. This means that a declared function 
or object needs be stored in such a way that it can be exported from a 
dll (in other words: it is included in the interface of the dll as an 
exportable function). If you use&nbsp;<code class="brush:cpp">FMX_ENTRYPT
</code> with a function declaration you tell the compiler to make sure 
the function can be exported from the dll. Again in other words, the 
functions in the plug-in can be exported from it if they are defined as 
entry points for Filemaker by using <code class="brush:cpp">__declspec(dllexport)</code>.
 There is actually only one function in the plug-in Software Development
 Kit that is defined as entry point. It is at the end of this header and
 is called <code class="brush:cpp">
FMExternCallProc</code>. This is the function that Filemaker uses to talk to your plug-in. It has to be specified as&nbsp;<code class="brush:cpp">dllexport
</code> otherwise the Visual C++-compiler will hide it and the function cannot be&nbsp;found by Filemaker.</p>
<p>The specifier&nbsp;<code class="brush:cpp">__declspec(dllimport)
</code> works the other way around. If you have an application or a 
library and you need external functions from a library somewhere 
outside, you can specify a function declaration in the&nbsp;former as 
dllimport, meaning that the function is somewhere outside in the latter.
 The application or library containing the dllimport function should be 
able to have fast access to the function in other library. When used in 
the source code of your plug-in, the the plug-in is the one that needs 
to have access and&nbsp;imports a function from Filemaker. The macro 
name that is given for the dllimport sttribute specifier is FMX_API. 
This is to designate that whenever the dllimport is used on function 
declarations in the plug-in, those functions are Filemaker API functions
 that are defined outside the plug-in, inside the Fiilemaker 
application.</p>
<h3>FMX_AUTOPTRRESET(x)</h3>
<p>The macro&nbsp;<code class="brush:cpp">FMX_AUTOPTRRESET(x)
</code> is used to reset autopointers. The defitions for the GCC compiler is simply <code class="brush:cpp">
reset(x)</code>. The one used for the Visual C++ compiler is a lot more complicated:</p>
<div><div id="highlighter_993711" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">this</code><code class="cpp plain">-&gt;operator=(*</code><code class="cpp keyword bold">static_cast</code><code class="cpp plain">&lt;UpCaster*&gt;(&amp;std::auto_ptr&lt;element_type&gt;(x)))</code></div></div></td></tr></tbody></table></div></div>
<p>To start with: what is an autopointer? It is just like a normal 
pointer, but it cleans up after you. That means when you assign an 
address of something to the autopointer, that something is destroyed at 
the moment the autopointer is destroyed. So this code:</p>
<div><div id="highlighter_12160" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp color1 bold">int</code> <code class="cpp plain">foo()</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">auto_ptr&lt;</code><code class="cpp color1 bold">int</code><code class="cpp plain">&gt; i (</code><code class="cpp keyword bold">new</code> <code class="cpp color1 bold">int</code><code class="cpp plain">);</code></div><div class="line number4 index3 alt1"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>will make sure your new int is no longer reserved in memory after the
 function. Using a normal pointer, the int would still hang there until 
the application is finished or until you delete it manually. The 
GCC-compiler definition for&nbsp;<code class="brush:cpp">FMX_AUTOPTRRESET(x)
</code> is <code class="brush:cpp">
reset(x)</code>. That means that the autopointer that calls this 
function (which always appears to happen from within its class 
definition; hence no point is required as in&nbsp;<code class="brush:cpp">
.reset(x)</code>) &nbsp;delete the thing it was pointing to and replaces that by <code class="brush:cpp">
x</code>, which should be the address of some new thing. A more complicated version is used for the Visual C++ compiler.</p>
<p>Note that the macro appears always to be called from within the 
Filemaker Plugin autopointer class, which is always inherited from 
the&nbsp;<code class="brush:cpp">std::auto_ptr
</code> class. The&nbsp;<code class="brush:cpp">FMX_AUTOPTRRESET(x)
</code> macro thus is always used to reset the autopointer that calls 
the defined function; i.e. to reset itself. This is where the&nbsp;<code class="brush:cpp">this-&gt;operator=
</code> part of the Visual C++ compiler version comes in. The&nbsp;<code class="brush:cpp">
auto_ptr
</code> class includes the assignment&nbsp;operator (=)&nbsp;as a valid 
way to transfer ownership from one object to another. Calling&nbsp;<code class="brush:cpp">
this-&gt;operator=
</code> ensures that what comes after it is the new value of the 
autopointer that uses the macro. Now the next part of the Visual C++ 
definition is the new object that the autopointer will point to:</p>
<div><div id="highlighter_584906" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">(*</code><code class="cpp keyword bold">static_cast</code><code class="cpp plain">&lt;UpCaster*&gt;(&amp;std::auto_ptr&lt;element_type&gt;(x)))</code></div></div></td></tr></tbody></table></div></div>
<p>Every time an inherited autopointer class is declared, its declaration includes a type definition of itself as <code class="brush:cpp">
UpCaster</code>. Thus, in FMXDateTime.h we find:</p>
<div><div id="highlighter_164043" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">DateTimeAutoPtr&nbsp;&nbsp;&nbsp; UpCaster;</code></div></div></td></tr></tbody></table></div></div>
<p>The&nbsp;<code class="brush:cpp">static_cast
</code> is a way of converting types C++, defined as <code class="brush:cpp">
static_cast&lt;new type&gt; (object)</code>. Doing so, the object is converted from one type to the new type. Because the new type, in this case, is an&nbsp;<code class="brush:cpp">UpCaster
</code> pointer, which is just a pointer to an alternatively defined type of the FMX&nbsp;<code class="brush:cpp">auto_ptr
</code> class, this type that is casted to will fit in neatly with the 
original autopointer that uses the macro. In fact, the only reason why 
it was type defined as&nbsp;<code class="brush:cpp">UpCaster
</code> in all the different autopointer definitions is to be able to 
use a single type in this macro for all the different class definitions 
from which it will be called. Now, what is exactly cast to an&nbsp;<code class="brush:cpp">UpCaster*
</code> (a pointer to an autopointer)? We’ll find that the field of&nbsp;<code class="brush:cpp">auto_ptr&lt;element_type&gt;(x)
</code> is the thing being cast. The&nbsp;<code class="brush:cpp">auto_ptr&lt;element_type&gt;
</code> is the basic version of the&nbsp;<code class="brush:cpp">std::auto_ptr
</code> class without a type assigned to it yet. Creating an&nbsp;<code class="brush:cpp">auto_ptr&lt;element_type&gt;(x)
</code> means that an autopointer is created for <code class="brush:cpp">
x</code>, but without specification of what type the autopointer points to. That’s what the&nbsp;<code class="brush:cpp">static_cast
</code> is for. It casts the raw autopointer to the autopointer&nbsp;<code class="brush:cpp">UpCaster
</code> that does know its type (namely the different types the autopointers point to in their respective classes). Because&nbsp;<code class="brush:cpp">static_cast&lt;UpCaster*&gt;
</code> returns a pointer to an <code class="brush:cpp">
UpCaster</code>, it has to be dereferenced to get a normal, hence the assignment should be <code class="brush:cpp">
*static_cast&lt;UpCaster*&gt;.</code></p>
<p>The reason why the <code class="brush:cpp">
reset()
</code>is not used for Visual C++-compilers is that it was simply not included in older versions of Visual C++. Hence all the trouble.</p>
<h3>64-bit definition (Filemaker 12 plug-in SDK)</h3>
<p>The Filemaker 12 plug-in SDK adds support for building 64-bit plugin 
that can be used for a Custom Web Publishing solution that uses 64-bit 
plug-ins.</p>
<div><div id="highlighter_607315" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">(_MSC_VER) &amp;&amp; </code><code class="cpp keyword bold">defined</code><code class="cpp plain">(_M_X64) || </code><code class="cpp keyword bold">defined</code><code class="cpp plain">(__GNUC__) &amp;&amp; </code><code class="cpp keyword bold">defined</code><code class="cpp plain">(_LP64)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_64BIT_PLUGIN_API</code></div><div class="line number3 index2 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div></div></td></tr></tbody></table></div></div>
<p>The <code class="brush:cpp">
_M_X64
</code>macro for the Visual C++-compiler and the _LP64 macro for the 
GCC-compiler are the macro’s telling the compiler to compile the code as
 64-bit. So, if you tell your compiler to compile a 64-bit plug-in, 
these macros are set and the&nbsp;<code class="brush:cpp">#define FMX_64BIT_PLUGIN_API
</code> is executed. This means that the identifier&nbsp;<code class="brush:cpp">FMX_64BIT_PLUGIN_API
</code> will be defined for the rest of the header (and all subsequent 
header that include this header), although it is not defined “as 
something”. Every time something has to be built as specifically 64-bit a
 test can be performed like</p>
<p>
</p><div><div id="highlighter_268468" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#ifdef FMX_64BIT_PLUGIN_API</code></div><div class="line number2 index1 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//do something 64-bit related</code></div><div class="line number3 index2 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">else</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//do something 32-bit related</code></div><div class="line number5 index4 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div></div></td></tr></tbody></table></div></div>
<p>&nbsp;</p>
<h2>Forward Definitions</h2>
<p>In this part of the FMXExtern.h header several classes and a lot of 
type definitions take place. First, however, there is a test for whether
 the compiler is compiling the code as C++:</p>
<p>
</p><div><div id="highlighter_598929" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#ifdef __cplusplus</code></div></div></td></tr></tbody></table></div></div>
<p>If you use a C++-compiler, the compiler will have set the&nbsp;<code class="brush:cpp">__cplusplus
</code> macro and continues compiling. If you use a C-compiler, it will skip everything immediately following the <code class="brush:cpp">
#ifdef
</code>and start compiling from an <code class="brush:cpp">
#else
</code>or&nbsp;<code class="brush:cpp">#endif
</code> directive. In this case there is an <code class="brush:cpp">
#else
</code>directive. Everything before the <code class="brush:cpp">
#else
</code>directive is compiled only by a C++ compiler. Everything after it is only done if the compiler is a C-compiler.</p>
<p>We’ll first cover the part that a C++ compiler would compile.</p>
<div><div id="highlighter_298287" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div><div class="line number42 index41 alt1">42</div><div class="line number43 index42 alt2">43</div><div class="line number44 index43 alt1">44</div><div class="line number45 index44 alt2">45</div><div class="line number46 index45 alt1">46</div><div class="line number47 index46 alt2">47</div><div class="line number48 index47 alt1">48</div><div class="line number49 index48 alt2">49</div><div class="line number50 index49 alt1">50</div><div class="line number51 index50 alt2">51</div><div class="line number52 index51 alt1">52</div><div class="line number53 index52 alt2">53</div><div class="line number54 index53 alt1">54</div><div class="line number55 index54 alt2">55</div><div class="line number56 index55 alt1">56</div><div class="line number57 index56 alt2">57</div><div class="line number58 index57 alt1">58</div><div class="line number59 index58 alt2">59</div><div class="line number60 index59 alt1">60</div><div class="line number61 index60 alt2">61</div><div class="line number62 index61 alt1">62</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">extern</code> <code class="cpp string">"C++"</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">namespace</code> <code class="cpp plain">fmx</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">{</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">class</code> <code class="cpp plain">Text;</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">class</code> <code class="cpp plain">Data;</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">class</code> <code class="cpp plain">ExprEnv;</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uint16;</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">int16;</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uchar;</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">int32;</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">int</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uint32;</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">( _MSC_VER )</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">__int64</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">int64;</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">__int64</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uint64;</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">( _M_X64)</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">uint64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptrtype;</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">else</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptrtype;</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">int16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundleid;</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">else</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp keyword bold">defined</code><code class="cpp plain">( _LP64 )</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">int64;</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uint64;</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">uint64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptrtype;</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundleid;</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">else</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">long</code> <code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">int64;</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">long</code> <code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">uint64;</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ptrtype;</code></div><div class="line number32 index31 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">int16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bundleid;</code></div><div class="line number33 index32 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div><div class="line number34 index33 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">errcode;</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">unichar;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div><div class="line number37 index36 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp plain">!</code><code class="cpp keyword bold">defined</code><code class="cpp plain">(FMX_64BIT_PLUGIN_API)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div><div class="line number38 index37 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// These are provided for backwards compatibility. Newly developed plugins(both 32-bit and 64-bit) should be specific about the sizes of</code></div><div class="line number39 index38 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// integers and not rely on ambiguous "long" data types.</code></div><div class="line number40 index39 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ulong;</code></div><div class="line number41 index40 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ushort;</code></div><div class="line number42 index41 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::int64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; longlong;</code></div><div class="line number43 index42 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div><div class="line number44 index43 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div><div class="line number45 index44 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">}</code></div><div class="line number46 index45 alt1"><code class="cpp plain">}</code></div><div class="line number47 index46 alt2"><code class="cpp keyword bold">extern</code> <code class="cpp string">"C"</code></div><div class="line number48 index47 alt1"><code class="cpp plain">{</code></div><div class="line number49 index48 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::Text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Text;</code></div><div class="line number50 index49 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Data;</code></div><div class="line number51 index50 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::ExprEnv&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_ExprEnv;</code></div><div class="line number52 index51 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::uchar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_UChar;</code></div><div class="line number53 index52 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::int16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Int16;</code></div><div class="line number54 index53 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::uint16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_UInt16;</code></div><div class="line number55 index54 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Int32;</code></div><div class="line number56 index55 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::uint32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_UInt32;</code></div><div class="line number57 index56 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::unichar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Unichar;</code></div><div class="line number58 index57 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::errcode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_ErrorCode;</code></div><div class="line number59 index58 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::ptrtype&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_PtrType;</code></div><div class="line number60 index59 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp plain">fmx::bundleid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_BundleID;</code></div><div class="line number61 index60 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Char;</code></div><div class="line number62 index61 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Boolean;</code></div></div></td></tr></tbody></table></div></div>
<p>This code is divided in blocks of&nbsp;<code class="brush:cpp"><code class="brush:cpp">extern "C++"
</code> </code> and <code class="brush:cpp">
extern "C"</code>. The&nbsp;<code class="brush:cpp">extern "C"
</code> block, however, is not closed yet. Only at the very end of the 
FMXExtern.h header we will find the closing accolade, enclosed again by a
 check of whether a C++ compiler is used:</p>
<div><div id="highlighter_601366" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#ifdef __cplusplus</code></div><div class="line number2 index1 alt1"><code class="cpp plain">}</code></div><div class="line number3 index2 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div></div></td></tr></tbody></table></div></div>
<p>This means that a C++-compiler will first encounter a small block of code wrapped in <code class="brush:cpp">
extern "C++"
</code>and the remainder of the file wrapped in <code class="brush:cpp">
extern "C"</code>. What does&nbsp;<code class="brush:cpp">extern "C"</code>
 keyword do? It makes sure that a code block is compiled with C-linkage 
instead of&nbsp;C++-linkage. This has to do with name mangling (or name 
decoration). Compiling code with C++-linkage, the C++-compiler will add 
certain information to names that it would not add if it compiled the 
same code with C-linkage. Because the&nbsp;plug-in that is created 
(using your own programming and the SDK) will be linked to externally, 
name mangling by the C++-compiler can obfuscate things. Telling the 
C++-compiler to compile code with C-linkage makes it easier for the 
created&nbsp;plug-in to be called by other programs such as Filemaker. 
Instead of looking for a difficult, name-mangled name (which&nbsp;could 
be mangled differentlydepending on the compiler's version) in your 
plug-in, Filemaker&nbsp;can simply look for the name of the function it 
needs to call. Some things are natively C++, however, so the&nbsp;<code class="brush:cpp">extern "C++"
</code> block first introduces those things that really need to be compiled with C++-linkage. (Note that, other than <code class="brush:cpp">
extern "C"</code>, explicitly stating&nbsp;<code class="brush:cpp">extern "C++"
</code> is not really necessary here, because only a C++-compiler will 
compile this block and it compiles with C++-linkage anyway. It is 
included in this header for clarity.)</p>
<p>The&nbsp;<code class="brush:cpp">extern "C++"
</code> block introduces a <code class="brush:cpp">
namespace
</code>called <code class="brush:cpp">
fmx</code>. The&nbsp;<code class="brush:cpp">
fmx namespace
</code> contains 3 classes called <code class="brush:cpp">
Text</code>,&nbsp;<code class="brush:cpp">Data
</code> and&nbsp;<code class="brush:cpp">
ExprEnv
</code> (Expression Environment).&nbsp;<code class="brush:cpp">Text</code> is defined in FMXText.h, the definition for&nbsp;<code class="brush:cpp">Data</code> can be found in header FMXData.h, and&nbsp;<code class="brush:cpp">ExprEnv</code> is found in FMXCalcEngine.h.</p>
<p>These forward declarations are followed by type definitions. Unsigned versions of&nbsp;<code class="brush:cpp">short
</code> and&nbsp;<code class="brush:cpp">char
</code> are type defined as&nbsp;<code class="brush:cpp">uint16
</code> and <code class="brush:cpp">
uchar</code>. A&nbsp;<code class="brush:cpp">short
</code> is defined as <code class="brush:cpp">
int16</code>. An&nbsp;<code class="brush:cpp">int
</code> is defined as&nbsp;<code class="brush:cpp">int32
</code> and&nbsp;<code class="brush:cpp">unsigned int
</code> as <code class="brush:cpp">
uint32</code>.</p>
<p>A new type&nbsp;<code class="brush:cpp">int64
</code> is defined as&nbsp;<code class="brush:cpp">__int64
</code> for the visual C++-compiler and its unsigned version is defined as <code class="brush:cpp">
uint64</code>. Again for the C++-compiler the new type&nbsp;<code class="brush:cpp">ptrtype
</code> (pointer type) is defined as an&nbsp;<code class="brush:cpp">
unsigned __int64
</code> or as an <code class="brush:cpp">
unsigned int</code>, depending on whether the compiler is set to compile a 64-bit plug-in or not. The <code class="brush:cpp">
bundleid
</code>is a new name for the&nbsp;<code class="brush:cpp">int16
</code> (<code class="brush:cpp">short</code>) that was defined just above.</p>
<p>Compiling with an GCC-compiler which compiles a 64-bit plug-in, the new type&nbsp;<code class="brush:cpp">int64
</code> is a long (and not <code class="brush:cpp">
__int64</code>, which is Microsoft specific) and the&nbsp;<code class="brush:cpp">uint64
</code> is an <code class="brush:cpp">
unsigned long</code>, which is also defined as a <code class="brush:cpp">
ptrtype</code>. The&nbsp;<code class="brush:cpp">bundleid
</code> is in this case defined as&nbsp;<code class="brush:cpp">int32
</code> (an normal <code class="brush:cpp">
int</code>).</p>
<p>Compiling with an GCC-compiler which compiles a 32-bit plug-in, the new type&nbsp;<code class="brush:cpp">int64
</code> is a <code class="brush:cpp">
long long</code>(and their unsigned version are also redefined). Instead of the <code class="brush:cpp">
int64</code>, the new&nbsp;<code class="brush:cpp">ptrtype
</code> is now defined as&nbsp;<code class="brush:cpp">uint32
</code> (an <code class="brush:cpp">
unsigned int</code>). The <code class="brush:cpp">
bundleid</code>, then, is in this case an&nbsp;<code class="brush:cpp">int16
</code> (a <code class="brush:cpp">
short</code>).</p>
<p>For both compilers compiling for both 64- and 32-bit, a type called&nbsp;<code class="brush:cpp">errcode
</code> (which we already encountered above) is introduced as being a <code class="brush:cpp">
short</code>. And the new type&nbsp;<code class="brush:cpp">unichar
</code> (UNICODE character) is the same as an <code class="brush:cpp">
unsigned short</code>.</p>
<p>Several older types are included for backwards compatibility. These are <code class="brush:cpp">
ulong</code>,&nbsp;<code class="brush:cpp">ushort
</code> and <code class="brush:cpp">
longlong</code>, but these shouldn’t be used anymore.</p>
<p>Now that those classes are declared and the types are defined, we enter the&nbsp;<code class="brush:cpp">extern "C"
</code> block. What we find here is again several type definitions. To 
be precise, the classes that were declared and the types that were 
defined in the&nbsp;<code class="brush:cpp">extern "C++"
</code> block are now redefined with other names. The only exception is&nbsp;<code class="brush:cpp">longlong
</code> (used in the FMXDateTime.h header). The reason these type get new type names in the&nbsp;<code class="brush:cpp">extern "C"
</code> block, is to ensure they can be used in later&nbsp;<code class="brush:cpp">extern "C"
</code> blocks without getting linker errors. What we end up with are the following type definitions:</p>
<div><div id="highlighter_561926" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_Text </code><code class="cpp comments">// a class</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_Data </code><code class="cpp comments">//another class</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_ExprEnv </code><code class="cpp comments">//yet another class</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_UChar </code><code class="cpp comments">//an unsigned character</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_Int16 </code><code class="cpp comments">//a short</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_UInt16 </code><code class="cpp comments">//an unsigned short</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_Int32 </code><code class="cpp comments">//an int</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_UInt32 </code><code class="cpp comments">//an unsigned int</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_Unichar </code><code class="cpp comments">//an unsigned short (used as UNICODE char)</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_ErrorCode </code><code class="cpp comments">// a short (used as error code)</code></div><div class="line number11 index10 alt2"><code class="cpp plain">FMX_PtrType </code><code class="cpp comments">// a (32-bit) int or a long for 32-bits compilation and an unsigned long or an unsigned long long for 64-bits compilation</code></div><div class="line number12 index11 alt1"><code class="cpp plain">FMX_BundleID </code><code class="cpp comments">// a short if compiled by Visual C++-compiler and also if compiled by GCC-compiler as 32-bit plug-in. But, this FMX_BundleID is an int if the GCC-compiler builds the plug-in as 64-bit.</code></div><div class="line number13 index12 alt2"><code class="cpp plain">FMX_Char </code><code class="cpp comments">//a char</code></div><div class="line number14 index13 alt1"><code class="cpp plain">FMX_Boolean </code><code class="cpp comments">// also a char</code></div></div></td></tr></tbody></table></div></div>
<p>Following these are several pre-64-bits type definitions. Such as <code class="brush:cpp">
FMX_ULong</code>, <code class="brush:cpp">
FMX_UShort</code>, <code class="brush:cpp">
FMX_Ptr</code>, <code class="brush:cpp">
FMX_Hdl</code>, etc. These should not be used anymore in the new 64-bit 
or 32-bit setup because they can cause problems when switching from 64- 
to 43-bits built and vice-versa.</p>
<p>When not using a C++-compiler to compile this header, the&nbsp;<code class="brush:cpp">#ifdef _cplusplus
</code> evaluated to false and the compiler skips to the <code class="brush:cpp">
#else
</code>directive from which it starts compiling. This block of code 
shows the same new names for types. Now, however, they are type defined 
directly to the type in the&nbsp;<code class="brush:cpp">extern "C++"</code> block (except for longlong). The classes, however, are type defined as void, because a C-compiler doesn’t recognize classes.</p>
<div><div id="highlighter_251929" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp keyword bold">void</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Text;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp keyword bold">void</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Data;</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp keyword bold">void</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_ExprEnv;</code></div><div class="line number4 index3 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_ULong;</code></div><div class="line number5 index4 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_UShort;</code></div><div class="line number6 index5 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_UChar;</code></div><div class="line number7 index6 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">unsigned </code><code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Unichar;</code></div><div class="line number8 index7 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_ErrorCode;</code></div></div></td></tr></tbody></table></div></div>
<h3>Old style definitions</h3>
<p>The old style definitions are as follows:</p>
<div><div id="highlighter_909027" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">long</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Long;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">short</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Short;</code></div><div class="line number3 index2 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Char;</code></div><div class="line number4 index3 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp color1 bold">char</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_Boolean;</code></div><div class="line number5 index4 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_Char*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Ptr;</code></div><div class="line number6 index5 alt1"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_Ptr*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Hdl;</code></div></div></td></tr></tbody></table></div></div>
<p><code class="brush:cpp">FMX_Long</code>, <code class="brush:cpp">
FMX_Short</code>,&nbsp;<code class="brush:cpp">FMX_Char
</code> and&nbsp;<code class="brush:cpp">FMX_Boolean
</code> are pretty straightforward. The&nbsp;<code class="brush:cpp">FMX_Ptr
</code> is a character pointer and the&nbsp;<code class="brush:cpp">FMX_Hdl
</code> is a pointer to a character pointer.</p>
<h3>Memory accessors for old style plugins</h3>
<p>This part of the FMXExtern.h header is commented as “new style 
plugins should not use these.” It exist of several function pointers 
that are used later on in this header in a struct.</p>
<div><div id="highlighter_151529" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROCPTR(FMX_Hdl,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_NewHandleCall)(FMX_Long size);</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_SetHandleSizeCall)(FMX_Hdl h, FMX_Long size);</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_PROCPTR(FMX_Long,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_GetHandleSizeCall)(FMX_Hdl h);</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_DisposeHandleCall)(FMX_Hdl h);</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_MoveHHiCall)(FMX_Hdl h);</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_LockHandleCall)(FMX_Hdl h);</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_UnlockHandleCall)(FMX_Hdl h);</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_PROCPTR(FMX_Ptr,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_NewPointerCall)(FMX_Long size);</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_PROCPTR(</code><code class="cpp keyword bold">void</code><code class="cpp plain">,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_DisposePointerCall)(FMX_Ptr p);</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_PROCPTR(FMX_Short,&nbsp;&nbsp;&nbsp;&nbsp; FMX_MemoryErrorCall)(</code><code class="cpp keyword bold">void</code><code class="cpp plain">);</code></div></div></td></tr></tbody></table></div></div>
<p>The function pointers are created using the&nbsp;<code class="brush:cpp">FMX_PROCPTR
</code> macro that was discussed above. In the next section (“new public
 callbacks”) some more care is taken to explain the details of the 
macro. Concerning these function pointers the compiler will define them 
with or without&nbsp;<code class="brush:cpp">__stdcall
</code> depending on the macro definition. This is the result of the first (without <code class="brush:cpp">
__stdcall</code>):</p>
<div><div id="highlighter_879648" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_Hdl (*FMX_NewHandleCall)(FMX_Long size);</code></div></div></td></tr></tbody></table></div></div>
<p>Later on, in the struct that will be discussed below, we find:</p>
<div><div id="highlighter_237206" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_NewHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNewHandle;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_SetHandleSizeCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cSetHandleSize;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_GetHandleSizeCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cGetHandleSize;</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_DisposeHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDisposeHandle;</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_MoveHHiCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cMoveHHi;</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_LockHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cLockHandle;</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_UnlockHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cUnlockHandle;</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_NewPointerCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNewPointer;</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_DisposePointerCall&nbsp;&nbsp;&nbsp;&nbsp; cDisposePointer;</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_MemoryErrorCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cMemoryError;</code></div></div></td></tr></tbody></table></div></div>
<p>Thus, for the old style plugins the following function pointers are included in the struct:</p>
<div><div id="highlighter_267034" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_NewHandleCall (*cNewHandle)(FMX_Long size);</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_SetHandleSizeCall (*cSetHandleSize)(FMX_Hdl h, FMX_Long size);</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_GetHandleSizeCall (*cGetHandleSize)(FMX_Hdl h);</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_DisposeHandleCall (*cDisposeHandle)(FMX_Hdl h);</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_MoveHHiCall (*cMoveHHi)(FMX_Hdl h);</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_LockHandleCall (*cLockHandle)(FMX_Hdl h);</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_UnlockHandleCall (*cUnlockHandle)(FMX_Hdl h);</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_NewPointerCall (*cNewPointer)(FMX_Long size);</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_DisposePointerCall (*cDisposePointer)(FMX_Ptr p);</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_MemoryErrorCall (*cMemoryError)(</code><code class="cpp keyword bold">void</code><code class="cpp plain">);</code></div></div></td></tr></tbody></table></div></div>
<p>To make these easier to use these struct functions all have a macro defined. (The <code class="brush:cpp">
struct 
</code><code class="brush:cpp">gFMX_ExternCallPtr
</code> is actually a type definition of the <code class="brush:cpp">
struct</code>&nbsp;declared in this header.)</p>
<div><div id="highlighter_327462" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_NewHandle(size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cNewHandle)(size)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_SetHandleSize(h, size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cSetHandleSize)(h, size)</code></div><div class="line number3 index2 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_GetHandleSize(h)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cGetHandleSize)(h)</code></div><div class="line number4 index3 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_DisposeHandle(h)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cDisposeHandle)(h)</code></div><div class="line number5 index4 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_MoveHHi(h)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cMoveHHi)(h)</code></div><div class="line number6 index5 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_LockHandle(h)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cLockHandle)(h)</code></div><div class="line number7 index6 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_UnlockHandle(h)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cUnlockHandle)(h)</code></div><div class="line number8 index7 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_NewPointer(size)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cNewPointer)(size)</code></div><div class="line number9 index8 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_DisposePointer(p)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cDisposePointer)(p)</code></div><div class="line number10 index9 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_MemoryError()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cMemoryError)()</code></div></div></td></tr></tbody></table></div></div>
<p>Therefore, old style plugins can use the following (macro’ed) function pointers:</p>
<div><div id="highlighter_1417" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_NewHandle </code><code class="cpp comments">//Return Handle to new data allocation.</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_SetHandleSize </code><code class="cpp comments">//Set size of allocated data at the Handle.</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_GetHandleSize </code><code class="cpp comments">//Returns size of allocated data at the Handle.</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_DisposeHandle </code><code class="cpp comments">//Frees the data at the Handle.</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_MoveHHi </code><code class="cpp comments">//moves allocated data at the Handle toward the top of the heap</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_LockHandle </code><code class="cpp comments">//Prevents the allocated data from moving in memory.</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_UnlockHandle </code><code class="cpp comments">//Allows the allocated data to move in memory.</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_NewPointer </code><code class="cpp comments">//Return Pointer to new data collection</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_DisposePointer </code><code class="cpp comments">//Frees the data the Pointer point to</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_MemoryError </code><code class="cpp comments">//Checks for errors resulting from the use of these ninefunctions.</code></div></div></td></tr></tbody></table></div></div>
<p>In which the parameters are&nbsp;<code class="brush:cpp">h
</code> (a <code class="brush:cpp">
char*</code>) or&nbsp;<code class="brush:cpp">size
</code> (a <code class="brush:cpp">
long</code>). Handles are pointers to pointers with which, in old style 
plugins, you could take care of data allocation management. These 
function were needed to do operations on parameters and results in 
the&nbsp;<code class="brush:cpp">struct
</code> we will discuss. For example, upon entering, the parameters 
handles should be locked in memory in order for them to stay at the same
 point in memory.</p>
<h3>New public callbacks</h3>
<p>The next part is commented as “new public callbacks”. What is a 
callback? It is a reference to a function that is passed as an argument 
to another function. One of its purposes is to hide information 
concerning the callback. The user simply knows there is a function and 
passes a pointer to this function as an argument to another function. 
The result is what the user will work with; the details of the callback 
function stay hidden. The “new public callbacks” are public because 
Filemaker let’s you use them. They consist of the following code:</p>
<div><div id="highlighter_671715" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_UChar&nbsp;&nbsp; FMX_ScriptControl;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">enum</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Halt,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Exit,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Resume,</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Pause</code></div><div class="line number8 index7 alt1"><code class="cpp plain">};</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_PROCPTR(FMX_ErrorCode, FMX_StartScriptCall)(</code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* fileName, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* scriptName, FMX_ScriptControl control, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Data* parameter);</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_PROCPTR(FMX_ErrorCode, FMX_CurrentEnvCall)(FMX_ExprEnv* env);</code></div><div class="line number11 index10 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_StartScript(fileName, scriptName, control, parameter) (gFMX_ExternCallPtr-&gt;cStartScript)(fileName, scriptName, control, parameter)</code></div><div class="line number12 index11 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_SetToCurrentEnv(env) (gFMX_ExternCallPtr-&gt;cCurrentEnv)(env)</code></div></div></td></tr></tbody></table></div></div>
<p>First there is yet another typedef. Now it is <code class="brush:cpp">
FMX_ScriptControl 
</code>that is defined as an<code class="brush:cpp">
unsigned char</code>. It is followed by an unnamed enumeration.</p>
<div><div id="highlighter_193158" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">kFMXT_Halt</code></div><div class="line number2 index1 alt1"><code class="cpp plain">kFMXT_Exit </code></div><div class="line number3 index2 alt2"><code class="cpp plain">kFMXT_Resume</code></div><div class="line number4 index3 alt1"><code class="cpp plain">kFMXT_Pause</code></div></div></td></tr></tbody></table></div></div>
<p>(The prefix “k” is Hungarian notation and means constant.) So a 
function called, for example, ManageScript(FMX_UShort) could have as its
 parameter&nbsp;<code class="brush:cpp">kFMXT_Halt</code>&nbsp;to tell the script to halt.</p>
<p>The enumeration is followed by two function pointers. First there is:</p>
<div><div id="highlighter_93654" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROCPTR(FMX_ErrorCode, FMX_StartScriptCall)(</code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* fileName, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* scriptName, FMX_ScriptControl control, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Data* parameter);</code></div></div></td></tr></tbody></table></div></div>
<p>Using our knowledge of the macro&nbsp;<code class="brush:cpp">FMX_PROCPTR()</code>, we know that this function pointer has return type <code class="brush:cpp">
FMX_ErrorCode</code>, it is identified by <code class="brush:cpp">
FMX_StartScriptCall</code>, and it has four parameters: two of type&nbsp;<code class="brush:cpp">
FMX_Text
</code> pointer (the&nbsp;<code class="brush:cpp">Text</code>&nbsp;class), one of type&nbsp;<code class="brush:cpp">FMX_Data</code>&nbsp;pointer (the&nbsp;<code class="brush:cpp">Data</code>&nbsp;class), and one of the newly defined type&nbsp;<code class="brush:cpp">FMX_ScriptControl</code>&nbsp;(an <code class="brush:cpp">
unsigned char</code>). The value of the latter is (as we could deduct 
from its inclusion in the “new public callbacks” part) one of the 
enumerator-list starting with <code class="brush:cpp">
kFMXT_Halt</code>. The function pointer is now a synonym for this function pointer:</p>
<div><div id="highlighter_665238" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">void</code> <code class="cpp plain">(*FMX_StartScriptCall)(</code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* fileName, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* scriptName, FMX_ScriptControl control, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Data* parameter)</code></div></div></td></tr></tbody></table></div></div>
<p>In the struct we will examine below we’ll find</p>
<div><div id="highlighter_747566" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_StartScriptCall cStartScript;</code></div></div></td></tr></tbody></table></div></div>
<p>Here the function pointer is given an actual name. The function pointer could now be read as:</p>
<div><div id="highlighter_253221" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_StartScriptCall (*cStartScript)(</code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* fileName, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Text* scriptName, FMX_ScriptControl control, </code><code class="cpp keyword bold">const</code> <code class="cpp plain">FMX_Data* parameter);</code></div></div></td></tr></tbody></table></div></div>
<p>&nbsp;The same goes for the next function pointer called <code class="brush:cpp">
FMX_CurrentEnvCall</code>:</p>
<div><div id="highlighter_134953" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_PROCPTR(FMX_ErrorCode, FMX_CurrentEnvCall)(FMX_ExprEnv* env);</code></div></div></td></tr></tbody></table></div></div>
<p>becomes</p>
<code class="brush:cpp">
<div><div id="highlighter_528852" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ErrorCode (*FMX_CurrentEnvCall)(FMX_ExprEnv* env); </code></div></div></td></tr></tbody></table></div></div>
</code>
<p>In the struct to be examined below we find:</p>
<div><div id="highlighter_587569" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_CurrentEnvCall cCurrentEnv;</code></div></div></td></tr></tbody></table></div></div>
<p>Therefore the struct has as a member a function pointer which we can rewrite as:</p>
<div><div id="highlighter_713289" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_CurrentEnvCall (*cCurrentEnv)(FMX_ExprEnv* env);</code></div></div></td></tr></tbody></table></div></div>
<p>This function pointer, called <code class="brush:cpp">
cCurrentEnv</code>, takes one argument, which is the&nbsp;<code class="brush:cpp">class ExprEnv
</code> (typedef’ed as&nbsp;<code class="brush:cpp">FMX_ExprEnv
</code> near the beginning of this header).</p>
<p>The next part of the “new public callbacks” defines two macros:</p>
<div><div id="highlighter_96772" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_StartScript(fileName, scriptName, control, parameter)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cStartScript)(fileName, scriptName, control, parameter)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">#</code><code class="cpp keyword bold">define</code> <code class="cpp plain">FMX_SetToCurrentEnv(env)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (gFMX_ExternCallPtr-&gt;cCurrentEnv)(env)</code></div></div></td></tr></tbody></table></div></div>
<p>The&nbsp;<code class="brush:cpp">FMX_StartScript
</code> macro is defined as <code class="brush:cpp">
gFMX_ExternCallPtr-&gt;cStartScript</code>.&nbsp;<code class="brush:cpp">FMX_SetToCurrentEnv
</code> is defined as <code class="brush:cpp">
gFMX_ExternCallPtr-&gt;cCurrentEnv</code>.&nbsp;<code class="brush:cpp">cStartScript</code>&nbsp;and&nbsp;<code class="brush:cpp">cCurrentEnv</code>&nbsp;are
 the two function pointers in the struct we still have to examine, of 
which we just examined two function pointers. The struct is not called <code class="brush:cpp">
gFMX_ExternCallPtr</code>, as you might expect, but a pointer to the struct is type defined as <code class="brush:cpp">
gFMX_ExternCallPtr</code>. So calling the function at the address of&nbsp;<code class="brush:cpp">gFMX_ExternCallPtr-&gt;cCurrentEnv</code> (with its parameters) will call the function of which we just described the function pointer <code class="brush:cpp">(*FMX_CurrentEnvCall)(FMX_ExprEnv* env)</code>.</p>
<p>This leaves us with two callbacks:</p>
<div><div id="highlighter_267427" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_StartScript(fileName, scriptName, control, parameter)</code></div></div></td></tr></tbody></table></div></div>
<p>and</p>
<div><div id="highlighter_45687" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_SetToCurrentEnv(env)</code></div></div></td></tr></tbody></table></div></div>
<p>You can use the&nbsp;<code class="brush:cpp">FMX_StartScript</code>&nbsp;function pointer as if it were a normal function (if it is initialized with a real function, that is) by passing it:</p>
<ul>
<li>two objects of class&nbsp;<code class="brush:cpp">Text
</code> containing the filename and scriptname respectively</li>
<li>one of the option of the enum (<code class="brush:cpp">kFMXT_Halt</code>,&nbsp;<code class="brush:cpp">kFMXT_Exit</code>,&nbsp;<code class="brush:cpp">kFMXT_Resume</code>&nbsp;or <code class="brush:cpp">
kFMXT_Pause</code>)</li>
<li>and finally an object of class&nbsp;<code class="brush:cpp">Data</code>&nbsp;that contains the scriptparameter</li>
</ul>
<p>You can use the&nbsp;<code class="brush:cpp">FMX_SetToCurrentEnv</code>&nbsp;by passing it an object of class <code class="brush:cpp">
ExprEnv</code>.</p>
<h3>Call Back Struct - prerequisites</h3>
<p>In the callback struct that is defined in the FMXExtern.h header is 
used to get information from Filemaker into our plugin. We call a 
function with a pointer to the struct as argument. After the call (back 
to Filemaker), the struct is filled with the information we need. Thus, 
in the struct all the information we need can be found. Before getting 
to discuss the struct and its members we get several enumerations. The 
first of which is the API version enumeration:</p>
<div><div id="highlighter_687849" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">enum</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kBadExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = -1,</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kDoNotEnable&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = -2,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k40ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 11,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k41ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 12,</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k50ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 14,</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k60ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 17,</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k70ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 50,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Jumping to 50</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k80ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 51,</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k110ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 52,</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">k120ExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 53,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Support for 64-bit plugins</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kCurrentExtnVersion = 53,</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kMinExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4,</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kMaxExtnVersion&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 255</code></div><div class="line number16 index15 alt1"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>We can use these values to determine the version (EXTeNsion VERsion) 
of the Filemaker API that calls our plugin functions. We can 
return&nbsp;<code class="brush:cpp">kBadExtnVersion</code>&nbsp;if the 
version doesn't support this version. If it is not supported, the 
version will be smaller than kMinExtnVersion or larger than 
kMaxExtnVersion. The only other thing we can send back to Filemaker in 
response&nbsp;to an&nbsp;<code class="brush:cpp">kFMXT_Init</code>&nbsp;call (see below) is <code class="brush:cpp">kCurrentExtnVersion</code>. (Filemaker 8.5, 9 and 10 use the same API as Filemaker 8, so that is why you don’t find <code class="brush:cpp">
k90ExtnVersion</code>. The newest version is&nbsp;<code class="brush:cpp">k120ExtnVersion</code>&nbsp;(the Filemaker 12 plug-in SDK) introduced with Filemaker 12, which adds 64-bit plug-in development to the <code class="brush:cpp">
k110ExtnVersion</code>.)</p>
<p>Then we have the ExternCallSwitch macro and the ExternCallSwitch enumeration.</p>
<div><div id="highlighter_920801" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_UChar&nbsp;&nbsp; FMX_ExternCallSwitch;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">enum</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Idle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_External&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3,</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Shutdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4,</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_DoAppPreferences&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5,</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_GetString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 7</code></div><div class="line number10 index9 alt1"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>The type FMX_ExternCallSwitch is defined as an unsigned char. In the callback struct we find this:</p>
<div><div id="highlighter_183825" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ExternCallSwitch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whichCall; </code><code class="cpp comments">// Which call FileMaker is making into the plug-in</code></div></div></td></tr></tbody></table></div></div>
The ExternCallSwitch enumeration gives us the values that it can have. 
(Values 2 and 6 are missing. They are for internal use and are defined 
kFMXT_Internal1 and kFMXT_Internal2.)
<p>Filemaker can call your plugin with any of these values. If it calls your plugin with <code class="brush:cpp">
kFMXT_Init</code>, you’ll want to&nbsp;return the API version of&nbsp;the plugin (<code class="brush:cpp">kCurrentExtnVersion</code>). If it calls with <code class="brush:cpp">
kFMXT_Idle</code>, Filemaker has detected free time and your plug-in can do some background processing. If whichcall is&nbsp;<code class="brush:cpp">kFMXT_External</code>&nbsp;you’ve
 used FileMaker Pro 4-6 style plugin function calls, but you shouldn’t 
do that. (After Filemaker 6 these were replaced by a new style of 
calling.) In the Filemaker 12 plug-in SDK you’ll find that this value is
 explicitely blocked by <code class="brush:cpp">
#if !defined(FMX_64BIT_PLUGIN_API)</code>, in case you compile the plug-in as 64-bit. When Filemaker calls your plugin with <code class="brush:cpp">
kFMX_Shutdown</code>, you plugin should clean up all the allocated memory. Having called your plugin with <code class="brush:cpp">
kFMXT_DoAppPreferences</code>, you should use your configure function. 
Filemaker calls your plugin with this value when the user clicks the 
“Configure” button in the Plug-In tab of the Preferences dialog in 
Filemaker. You can disable this button, in which case you won’t ever get
 the&nbsp;<code class="brush:cpp">kFMXT_DoAppPreferences</code>&nbsp;call. Filemaker can also call your plugin with <code class="brush:cpp">kFMXT_GetString</code>. When Filemaker does so, it wants to receive one of three strings back from your plugin. Together with the&nbsp;<code class="brush:cpp">kFMXT_GetString</code>&nbsp;call, Filemaker sends a parameter. The value of this parameter (of <code class="brush:cpp">
typedef</code>’ed type <code class="brush:cpp">
FMX_Strings</code>) determines which of the three strings Filemaker 
wants back from you. The three values are defined in the following 
GetString enumeration.</p>
<div><div id="highlighter_487223" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_UChar&nbsp;&nbsp; FMX_Strings;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Different strings that may be asked for by kFMXT_GetString</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">enum</code>&nbsp;</div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_OptionsStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 131,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The option string</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_NameStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 128,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Name of the plug-in</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_AppConfigStr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Help text to display in FileMaker application preferences</code></div><div class="line number7 index6 alt2"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>If the&nbsp;<code class="brush:cpp">kFMXT_OptionsStr</code>&nbsp;accompanies the <code class="brush:cpp">
kFMXT_GetString</code>, Filemaker wants the option string of your plugin
 passed back to it. The options string (or feature string) covers the 
options Filemaker should set for your plug-in. The string consists of 11
 characters, which define the following options:</p>
<ul>
<li>Characters 1 to 4: the 4-character ID of your plugin. The ID must be
 unique for each Plug-In and must not begin with "F", "FM", or "Web". 
For the Mac OS X, it is recommended that you set the creator type of the
 plug-in to this same value. The ID can only contain low-ASCII 
alphanumeric characters (such as 0-9, A-Z, and a-z).</li>
<li>Character 5: this is always “1”</li>
</ul>
<p>The next 6 characters can be “Y” or “n” depending on whether you want to set the option.</p>
<ul>
<li>Character 6: “Y” if the plugin should have a “Configure” button 
enabled in the Plug-Ins tab of the Preferences dialog. Your plugin will 
receive the&nbsp;<code class="brush:cpp">kFMXT_DoAppPreferences</code>&nbsp;message from Filemaker if you set this option to “Y”.</li>
<li>Character 7: “Y” if you want to use old external functions. So, make sure to set it to “n”.</li>
<li>Character 8: Always set to “n”.</li>
<li>Character 9: “Y” if you want your plugin to use idle time processing. Your plugin will receive the&nbsp;<code class="brush:cpp">kFMXT_Idle</code>&nbsp;message if set to “Y”.</li>
<li>Character 10: Always set to “n”.</li>
<li>Character 11: Always set to “n”.</li>
</ul>
<p>The string that you pass back to Filemaker if it calls you with the&nbsp;<code class="brush:cpp">kFMXT_GetString</code>&nbsp;and the&nbsp;<code class="brush:cpp">kFMXT_OptionsStr</code>&nbsp;should
 therefore be of the following format, where “PLUG” should be replaced 
by your 4 character plugin ID and the X’s should be replaced by “Y” or 
“n”:</p>
<div><div id="highlighter_277683" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp string">"PLUG1XnnXnn"</code></div></div></td></tr></tbody></table></div></div>
<p>So, in response to a call by Filemaker with parameter&nbsp;<code class="brush:cpp">kFMXT_GetString</code>&nbsp;and <code class="brush:cpp">
kFMXT_OptionsStr</code>, your plugin has to send the ID and the options for the “Configure” button and idle processing formatted as the string above.</p>
<p>Now that we’ve had this complicated option string, 
which&nbsp;indeed&nbsp;appears not that complicated, we’ll deal with the
 other strings Filemaker can send to you. How to respond to <code class="brush:cpp">
kFMXT_NameStr</code>? You send Filemaker the name of your plugin. Easy. But what about the <code class="brush:cpp">kFMXT_AppConfigStr</code>?
 It is the plugin description that appears below&nbsp;your plug-in if 
you select yours in the Plug-Ins tab of the Preferences dialog. Have a 
look at the tab and, if you have a plug-in installed, you’ll see the 
text there. Send it to Filemaker and it will appear there.</p>
<p>The next enumeration is the idle level enumeration.</p>
<div><div id="highlighter_704113" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_UChar&nbsp;&nbsp; FMX_IdleLevel;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">enum</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_UserIdle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The user hasn't done anything for 30 seconds or more.</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_UserNotIdle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The user has done something within 30 seconds.</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_ScriptPaused&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The user is running a script that is paused.</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_ScriptRunning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The user is running a script.</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Unsafe&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Same as if unsafeCalls is set to true.</code></div><div class="line number9 index8 alt2"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>The type&nbsp;<code class="brush:cpp">FMX_IdleLevel</code>&nbsp;type is <code class="brush:cpp">
typedef</code>’ed as unsigned char. You’ll only have to deal with it if 
you have set the ninth character of the options string (that you have to
 send to Filemaker in response to a&nbsp;<code class="brush:cpp">kFMXT_GetString</code>&nbsp;call with parameter <code class="brush:cpp">
kFMXT_OptionsStr</code>). When Filemaker calls your plugin with <code class="brush:cpp">
kFMXT_Idle</code>, it will send an extra parameter giving your plugin 
the idle level. This can be any of the above enumerator-list. The 
comments in the header are pretty slef-explanatory, except for <code class="brush:cpp">
kFMXT_Unsafe</code>. In the callback struct we find:</p>
<div><div id="highlighter_650174" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_Boolean unsafeCalls; </code><code class="cpp comments">// True if unsafe for non-memory calls</code></div></div></td></tr></tbody></table></div></div>
<p>This tells you that non-memory calls are unsafe is this Boolean is set to true. When you receive a&nbsp;<code class="brush:cpp">kFMXT_Idle</code>&nbsp;call with parameter <code class="brush:cpp">
kFMXT_Unsafe
</code>you also know that non-memory calls are unsafe. This simply means that in response to this call your plugin should do … nothing!</p>
<p>There is still one enumeration left before we get to the struct: the FMX_Application enumeration.</p>
<div><div id="highlighter_33756" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp plain">FMX_UChar&nbsp;&nbsp; FMX_Application;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">enum</code></div><div class="line number3 index2 alt2"><code class="cpp plain">{</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Developer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0,</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Pro&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 1,</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Runtime&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2,</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Server&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 3,</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Web&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 4,</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">kFMXT_Mobile&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 5</code></div><div class="line number10 index9 alt1"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>These are send together with the&nbsp;<code class="brush:cpp">kFMXT_Init</code>&nbsp;call
 to your plugin and are pretty self-explanatory. They tell you which 
kind of Filemaker application is calling your plugin. The&nbsp;<code class="brush:cpp">FMXT_Developer</code>&nbsp;value
 is for Filemaker Advanced. If you’ve never heard of runtime: one of the
 features of Filemaker Advanced is to make a runtime application out of a
 Filemaker solution. This runtime version can be used without Filemaker 
Pro (Advanced) as a stand-alone application. The&nbsp;<code class="brush:cpp">kFMXT_Web</code>&nbsp;parameter
 tells you it is a Costum Web Publishing application that is sending the
 call. There are actually three other items missing from the 
enumerator-list in the header (of the new Filemaker 12 plug-in SDK?). 
These are:</p>
<div><div id="highlighter_264715" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">kFMXT_XDBC = 6, </code><code class="cpp comments">// This process does not currently load plug-ins </code></div><div class="line number2 index1 alt1"><code class="cpp plain">kFMXT_SASE = 7, </code><code class="cpp comments">// Server scripting process </code></div><div class="line number3 index2 alt2"><code class="cpp plain">kFMXT_IWP = 8 </code><code class="cpp comments">// Instant Web Publishing process</code></div></div></td></tr></tbody></table></div></div>
<p>You can add these yourself to the enumeration (according to <a href="http://filemaker.463488.n4.nabble.com/Updated-Plug-in-SDK-for-64-bit-available-td4657934.html">this</a> post).</p>
<p>Now we are finally able to examine the callback struct, the External Call Struct. We have a declaration:</p>
<div><div id="highlighter_912856" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_ExternCallStruct;</code></div></div></td></tr></tbody></table></div></div>
<p>It is called the <code class="brush:cpp">
FMX_ExternCallStruct</code>, which means that it is a struct that is 
used by your plug-in to receive external calls from Filemaker. The 
declaration is immediately followed by two type definitions:</p>
<div><div id="highlighter_548161" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">typedef</code> <code class="cpp keyword bold">struct</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp plain">FMX_ExternCallStruct *FMX_ExternCallPtr;</code></div><div class="line number2 index1 alt1"><code class="cpp keyword bold">typedef</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <code class="cpp keyword bold">void</code> <code class="cpp plain">(*FMX_ExternCallProc)(FMX_ExternCallPtr);</code></div></div></td></tr></tbody></table></div></div>
<p>The first defines&nbsp;<code class="brush:cpp">*FMX_ExternCallPtr</code>&nbsp;as <code class="brush:cpp">
struct FMX_ExternCallStruct</code>. Now, instead of writing code within a function like:</p>
<div><div id="highlighter_364294" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">FMX_ExternCallStruct InstanceOfThisStruct; </code></div><div class="line number2 index1 alt1"><code class="cpp plain">InstanceOfThisStruct.memberfunction();</code></div></div></td></tr></tbody></table></div></div>
<p>We can write it a little shorter like:</p>
<div><div id="highlighter_107893" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ExternCallPtr InstanceOfThisStructPtr;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">InstanceOfThisStructPtr-&gt;memberfunction();</code></div></div></td></tr></tbody></table></div></div>
<p>(Note the use of “<code class="brush:cpp">-&gt;</code>” when accessing a pointer’s member.)</p>
<p>The next type definition defines a new function pointer, the External Call Procedure. It is defined as:</p>
<div><div id="highlighter_841326" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">(*FMX_ExternCallProc)(FMX_ExternCallPtr)</code></div></div></td></tr></tbody></table></div></div>
<p>with return type void. In the External Call Struct&nbsp;<code class="brush:cpp">FMX_ExternCallStruct</code>&nbsp;we’ll find the following:</p>
<div><div id="highlighter_630290" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ExternCallProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entryPoint;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The pointer the application calls</code></div></div></td></tr></tbody></table></div></div>
<p>Using our knowledge of function pointers we now know that this is:</p>
<div><div id="highlighter_926781" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ExternCallProc (*entryPoint)(FMX_ExternCallPtr);</code></div></div></td></tr></tbody></table></div></div>
<p>A function with return type&nbsp;<code class="brush:cpp">FMX_ExternCallProc</code>&nbsp;(<code class="brush:cpp">void</code>). It is used by Filemaker to call your plug-in.</p>
<p>After these types we get to the actual struct, of which we discussed several features already.</p>
<h3>The actual external callback struct</h3>
<p>The struct has a packed status, of which the macros are discussed above, so we will not show these macro here:</p>
<div><div id="highlighter_567156" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div><div class="line number39 index38 alt2">39</div><div class="line number40 index39 alt1">40</div><div class="line number41 index40 alt2">41</div><div class="line number42 index41 alt1">42</div><div class="line number43 index42 alt2">43</div><div class="line number44 index43 alt1">44</div><div class="line number45 index44 alt2">45</div><div class="line number46 index45 alt1">46</div><div class="line number47 index46 alt2">47</div><div class="line number48 index47 alt1">48</div><div class="line number49 index48 alt2">49</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">struct</code> <code class="cpp plain">FMX_ExternCallStruct</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Passed in every call</code></div><div class="line number4 index3 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_Int16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extnVersion;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Version of this structure, set to the value of kCurrentExtnVersion</code></div><div class="line number5 index4 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_BundleID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; resourceID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The resource fork ID of the plug-in</code></div><div class="line number6 index5 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_ExternCallProc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; entryPoint;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// The pointer the application calls</code></div><div class="line number7 index6 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cfmCalls;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// True if plug-in is old style CFM format</code></div><div class="line number8 index7 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_ExternCallSwitch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whichCall;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// Which call FileMaker is making into the plug-in</code></div><div class="line number9 index8 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_Boolean&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsafeCalls;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// True if unsafe for non-memory calls</code></div><div class="line number10 index9 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Parameters for the calls; any parameter not used by a call is set to zero.</code></div><div class="line number11 index10 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_UChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1;</code></div><div class="line number12 index11 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm2;</code></div><div class="line number13 index12 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm3;</code></div><div class="line number14 index13 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// The meanings of parm1..parm3 in terms of the various messages:</code></div><div class="line number15 index14 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; Msg&nbsp;&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parm1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parm2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parm3</code></div><div class="line number16 index15 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_Init&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Application value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; App vers unicode c str*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]</code></div><div class="line number17 index16 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_Idle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_IdleLevel value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [reserved]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]</code></div><div class="line number18 index17 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_External&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Funct str index&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Parameter text**</code></div><div class="line number19 index18 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_Shutdown&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]</code></div><div class="line number20 index19 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_DoAppPreferences&nbsp;&nbsp;&nbsp;&nbsp; [unused]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [unused]</code></div><div class="line number21 index20 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; kFMXT_GetString&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FMX_Strings value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Windows lang ID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Maximum size of string to return</code></div><div class="line number22 index21 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//</code></div><div class="line number23 index22 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//(* same as GetAppVersion, e.g. "Pro 7.0v4" )</code></div><div class="line number24 index23 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//(** Parameter from calculation as text, in kEncoding_ASCII_Mac or kEncoding_ShiftJIS_Mac; Result passed back to FileMaker must match encoding.)</code></div><div class="line number25 index24 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Passed in every call</code></div><div class="line number26 index25 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; instanceID;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// ID of the plug-in</code></div><div class="line number27 index26 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; On Windows, it is the Instance ID of the plug-in.</code></div><div class="line number28 index27 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">//&nbsp;&nbsp;&nbsp;&nbsp; On Mac OS X, it is the BundleRef of the plug-in.</code></div><div class="line number29 index28 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Result from a call</code></div><div class="line number30 index29 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; result;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code><code class="cpp comments">// kFMXT_Init returns it's kCurrentExtnVersion</code></div><div class="line number31 index30 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Unused&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div><div class="line number32 index31 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unused;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </code></div><div class="line number33 index32 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">if</code> <code class="cpp plain">!</code><code class="cpp keyword bold">defined</code><code class="cpp plain">(FMX_64BIT_PLUGIN_API)</code></div><div class="line number34 index33 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// Call backs for old plug-ins</code></div><div class="line number35 index34 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_NewHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNewHandle;</code></div><div class="line number36 index35 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_SetHandleSizeCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cSetHandleSize;</code></div><div class="line number37 index36 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_GetHandleSizeCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cGetHandleSize;</code></div><div class="line number38 index37 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_DisposeHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cDisposeHandle;</code></div><div class="line number39 index38 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_MoveHHiCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cMoveHHi;</code></div><div class="line number40 index39 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_LockHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cLockHandle;</code></div><div class="line number41 index40 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_UnlockHandleCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cUnlockHandle;</code></div><div class="line number42 index41 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_NewPointerCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cNewPointer;</code></div><div class="line number43 index42 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_DisposePointerCall&nbsp;&nbsp;&nbsp;&nbsp; cDisposePointer;</code></div><div class="line number44 index43 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_MemoryErrorCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cMemoryError;</code></div><div class="line number45 index44 alt2"><code class="cpp plain">#</code><code class="cpp keyword bold">endif</code></div><div class="line number46 index45 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp comments">// New public callbacks</code></div><div class="line number47 index46 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_StartScriptCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cStartScript;</code></div><div class="line number48 index47 alt1"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">FMX_CurrentEnvCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cCurrentEnv;</code></div><div class="line number49 index48 alt2"><code class="cpp plain">};</code></div></div></td></tr></tbody></table></div></div>
<p>The first six members of the callback struct are passed in with every call. The first is <code class="brush:cpp">
FMX_Int16 extnVersion</code>, a short that has one of the values of the 
API enumeration. You should check in your plug-in whether it is smaller 
or larger than the minimal and maximum values of the enumeration and if 
this is the case return&nbsp;<code class="brush:cpp">kBadExtnVersion</code>&nbsp;back to Filemaker. If the version is OK you should send back the version of the API used to create your plug-in, which is <code class="brush:cpp">
kCurrentExtnVersion</code>. The Filemaker Pro 10 Advanced Development Guide mentions that only these two message should be sent in response to the&nbsp;<code class="brush:cpp">kFMX_Init</code>&nbsp;message. There is actually a third value that you can give as result to Filemaker, which is <code class="brush:cpp">kDoNotEnable</code>.
 If you pass this value bak to Filemaker, Filemaker disables the 
plug-in. You will find the plug-in in the Plug-Ins tab of the 
Preferences dialog, but its checkbox is unchecked.</p>
<p>The second,&nbsp;<code class="brush:cpp">FMX_BundleID resourceID</code>&nbsp;is
 the “resource fork ID of the plug-in”. The resource fork is an extra 
file that was needed for older Mac OS X plug-ins and is no longer 
needed.</p>
<p>The&nbsp;<code class="brush:cpp">FMX_ExternCallProc entryPoint</code>&nbsp;is the entry point for Filemaker into your plug-in. It is explained at the below.</p>
<p>The&nbsp;<code class="brush:cpp">FMX_Boolean cfmCalls</code>&nbsp;is not used anymore. It is always set to false. It was used for Code Fragment Manager files (Mac OS X).</p>
<p>The&nbsp;<code class="brush:cpp">FMX_ExternCallSwitch whichCall</code>&nbsp;is
 set by Filemaker to one of the values of the ExternCallSwitch 
enumeration. Every time Filemaker calls your plug-in you should evaluate
 the&nbsp;<code class="brush:cpp">whichCall</code>&nbsp;member of the&nbsp;<code class="brush:cpp">struct</code>&nbsp;that is passed to you plug-in and act accordingly.</p>
<p>The sixth member that is always passed in the callback struct is <code class="brush:cpp">
FMX_Boolean unsafeCalls</code> , which is true if non-memory calls should not be made and false if you can go ahead.</p>
<p>Three parameters can enter your plug-in when a callback struct is passed to it:</p>
<div><div id="highlighter_923008" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_UChar&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm1;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm2;</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_PtrType&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; parm3;</code></div></div></td></tr></tbody></table></div></div>
<p>Depending on the&nbsp;<code class="brush:cpp">whichCall</code>&nbsp;value these parameters have different implications which are explained in the header file. To summarize:</p>
<p>The&nbsp;<code class="brush:cpp">kFMX_Init</code>&nbsp;value is accompanied by a Filemaker API version value and the Filemaker version of the calling Filemaker application.</p>
<p>The&nbsp;<code class="brush:cpp">kFMX_Idle</code>&nbsp;value is accompanied by an Idle level value.</p>
<p>The&nbsp;<code class="brush:cpp">kFMX_External</code> is not used.</p>
<p>The&nbsp;<code class="brush:cpp">kFMX_Shutdown</code> and&nbsp;<code class="brush:cpp">kFMX_DoAppPreferences</code>&nbsp;have no parameters. You just clean up the memory used by your plug-in or show the user an options dialog.</p>
<p>The&nbsp;<code class="brush:cpp">kFMX_GetString</code>&nbsp;uses all 
three of the parameters. The first is one of the values of the GetString
 enumeration to which you respond by sending the appropriate string back
 to Filemaker (that is an Options String, a Plug-In Name or a Plug-In 
Description). The&nbsp;<code class="brush:cpp">parm2</code>&nbsp;is the Windows language ID. It can be looked up <a href="http://www.merzwaren.com/snippets/LanguageMapping.c">here</a>.
 The third is the maximum size of the string you can return. In case of 
the options string it is probably 11, else it is longer. Check the size 
before returning a string.</p>
<p>The next member (<code class="brush:cpp">FMX_PtrType instanceID</code>)
 of the callback struct tells you the instance ID of your plug-in. In 
Windows and on Mac your plug-in gets registered by the OS (Operating 
System) when it starts and it gets an ID appointed to it. 
Whenever&nbsp;the OS&nbsp;wants to send something to your 
application,&nbsp;it uses this ID. You can use the ID too, if you want 
Windows or Mac to do something with your plug-in. For example, if, on 
Windows, you want to load a string from a string table you have to pass 
the ID (or INSTANCE) of your running plug-in using the 
windows-specific&nbsp;<code class="brush:cpp">LoadString</code>&nbsp;function.
 Or, on Mac OS X, if you need a string from a localized string from a 
bundle’s string file you can use Mac function <code class="brush:cpp">CFBundleCopyLocalizedString</code>&nbsp;with the bundle ID of your plug-in.</p>
<p>The following member we’ll discuss is&nbsp;<code class="brush:cpp">FMX_PtrType result</code>. Set this value to your response to the&nbsp;<code class="brush:cpp">kFMX_Init</code> call and the <code class="brush:cpp">kFMX_GetString</code> all by Filemaker.</p>
<p>After the “unused” member there are several callbacks that should not
 be used. They are explicitly skipped when compiling a 64-bit plug-in 
and you shouldn’t use them. They are followed by the two new public 
callbacks:</p>
<div><div id="highlighter_385541" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_StartScriptCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cStartScript;</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_CurrentEnvCall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cCurrentEnv;</code></div></div></td></tr></tbody></table></div></div>
<p>These are discussed at length above. But what is not explained is how
 they get initialized. We’ll discuss that below. (Note that the “c” is 
probably Hungarian notation for “callback”.)</p>
<p>That’s all there is to the External Callback Struct! In Summary, you can or should use the following items:</p>
<div><div id="highlighter_333088" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_Int16 extnVersion;</code><code class="cpp comments">//Version of this structure, set it to kCurrentExtnVersion</code></div><div class="line number2 index1 alt1"><code class="cpp plain">FMX_ExternCallSwitch&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; whichCall;</code><code class="cpp comments">// Which call FileMaker is making into the plug-in</code></div><div class="line number3 index2 alt2"><code class="cpp plain">FMX_Boolean unsafeCalls;</code><code class="cpp comments">// True if unsafe for non-memory calls</code></div><div class="line number4 index3 alt1"><code class="cpp plain">FMX_UChar&nbsp;&nbsp;&nbsp; parm1; </code><code class="cpp comments">// might accompany a whichCall</code></div><div class="line number5 index4 alt2"><code class="cpp plain">FMX_PtrType&nbsp; parm2; </code><code class="cpp comments">// might accompany a whichCall</code></div><div class="line number6 index5 alt1"><code class="cpp plain">FMX_PtrType&nbsp; parm3; </code><code class="cpp comments">// might accompany a whichCall</code></div><div class="line number7 index6 alt2"><code class="cpp plain">FMX_PtrType&nbsp; instanceID; </code><code class="cpp comments">// ID of the plug-in</code></div><div class="line number8 index7 alt1"><code class="cpp plain">FMX_PtrType&nbsp; result;</code><code class="cpp comments">// put return value here if Filemaker asks something</code></div><div class="line number9 index8 alt2"><code class="cpp plain">FMX_StartScriptCall cStartScript;</code><code class="cpp comments">// start a Filemaker script</code></div><div class="line number10 index9 alt1"><code class="cpp plain">FMX_CurrentEnvCall&nbsp; cCurrentEnv; </code><code class="cpp comments">// get a the current expression environment</code></div></div></td></tr></tbody></table></div></div>
<p>After the struct we get the following function declaration:</p>
<div><div id="highlighter_271803" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">extern</code> <code class="cpp keyword bold">void</code> <code class="cpp plain">FMX_ENTRYPT FMExternCallProc(FMX_ExternCallPtr pb); </code></div></div></td></tr></tbody></table></div></div>
<p>The first is a declaration of a function we did not encounter yet. It is called <code class="brush:cpp">
FMExternCallProc</code>, returns a void and takes argument an&nbsp;<code class="brush:cpp">FMX_ExternCallPtr pb</code>. This parameter was typedef’ed before the definition of the struct as being a&nbsp;<code class="brush:cpp">struct FMX_ExternCallStruct
</code> pointer. In the source files of your plug-in you should define 
this function! This is obligatory because this is the ENTRYPoinT of 
Filemaker to your application. Using this method, Filemaker passes you a
 pointer to the callback struct <code class="brush:cpp">
FMX_ExternCallPtr</code>. This means that you’ll never have to create an instance of this struct yourself.</p>
<ol>
<li>1.Filemaker creates an instance of the <code class="brush:cpp">
FMX_ExternCallStruct</code>.</li>
<li>2.Filemaker creates a pointer to this instance.</li>
<li>3.It passes the struct to your plug-in using the entry point function <code class="brush:cpp">
FMExternCallProc</code>.</li>
<li>4.Your plug-in should then save a (global) pointer to Filemaker’s <code class="brush:cpp">
FMX_ExternallStruct</code>.</li>
</ol>
<p>This way you always have access to the struct that is actually 
“owned” by Filemaker. But, you have access to it via this function that 
passes you the pointer, you could even dereference the pointer and 
change it directly, although that is not necessary because the pointer 
is enough to work with. The extern keyword that precedes the function 
declaration does nothing. It never does when declaring functions. It is 
probably just there to signal you that this is just a declaration and 
you still have to do something with it. Or it is there to accommodate 
older style compilers.</p>
<p>Where to save the pointer you received? You can use the global that is declared here:</p>
<div><div id="highlighter_872262" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp keyword bold">extern</code> <code class="cpp plain">FMX_ExternCallPtr gFMX_ExternCallPtr;</code></div></div></td></tr></tbody></table></div></div>
<p>This is a pointer to a&nbsp;<code class="brush:cpp">struct FMX_ExternCallStruct</code> and is called <code class="brush:cpp">
gFMX_EternCallPtr</code>. The g is hungarion notation and stands for 
global. This pointer is global because it is at file scope (not in a 
function, struct, class, or namespace) and is thus accessible by all 
other files of your plug-in. The extern keyword is here for a reason. It
 signals to the compiler that this variable is still to be defined 
somewhere else. (Whithout the keyword a variable is always defined when 
it is global.) In this way you are forced to define it. Where to define 
it then? You should do that in the <code class="brush:cpp">
FMExternCallProc</code>:</p>
<div><div id="highlighter_560185" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMExternCallProc(FMX_ExternCallPtr pb)</code></div><div class="line number2 index1 alt1"><code class="cpp plain">{</code></div><div class="line number3 index2 alt2"><code class="cpp spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="cpp plain">gFMX_ExternCallPtr = pb;</code></div><div class="line number4 index3 alt1"><code class="cpp plain">}</code></div></div></td></tr></tbody></table></div></div>
<p>If you do so, you will have a callback struct that you can access via <code class="brush:cpp">
gFMX_ExternCallPtr</code>.</p>
<p>Now that we know that the struct is actually created by Filemaker, 
then what about the function pointer members? The members&nbsp;<code class="brush:cpp">FMX_StartScriptCall cStartScript</code> and&nbsp;<code class="brush:cpp">FMX_CurrentEnvCall cCurrentEnv</code>
 are not initialized and are pointers to garbage. They are declared as 
pointers to function, but they need to point to actual functions in 
order to be called. Again, it is Filemaker’s job to assign real 
functions to these pointers. It does that before the first call to your 
plug-in is made, so you do not have worry about it. Filemaker passes you
 a pointer to callback struct&nbsp;<code class="brush:cpp">FMX_ExternCallProc</code> which already has the two function pointers pointing to function. And again, these function are “owned” by Filemaker.</p>
<p>When your plug-in has been called with a message to initialize, your 
plug-in can respond with calling the function pointed to by <code class="brush:cpp">
cStartScript</code>. This function is a Filemaker function and not one 
of your plug-in’s. That why this procedure is called a callback and the 
struct containing the callback function pointer a Call Back Struct.</p>
<p>Then, what about the function pointer <code class="brush:cpp">
FMX_ExternCallProc entryPoint</code>? Who’s is it? We have a&nbsp;<code class="brush:cpp">FMExternCallProc</code>
 function that is our own function. It’s declared in this plug-in file 
and can be used in all the other plug-in files. In the struct the 
member&nbsp;<code class="brush:cpp">entryPoint</code> is commented as “the pointer the application calls”. Like the callbacks&nbsp;<code class="brush:cpp">cStartScript</code> and <code class="brush:cpp">
cCurrentEnv</code>, the&nbsp;<code class="brush:cpp">entryPoint</code> is initialized by Filemaker. But this time, it is not a function “owned” by Filemaker that the&nbsp;<code class="brush:cpp">entryPoint</code> points to. Rather, it is the entry point of you plug-in that Filemaker sets to <code class="brush:cpp">entryPoint</code>. Note that the&nbsp;<code class="brush:cpp">FMExternCallProc()</code> has the macro&nbsp;<code class="brush:cpp">ENTRPT</code> before the declaration. The Visual C++-compiler will substitute it with <code class="brush:cpp">
__declspec(dllexport)</code>, meaning that this function is ready to be exported out of your plug-in.</p>
<p>How will Filemaker import this function in order to use it in its call to <code class="brush:cpp">
FMExternCallProc()</code>?</p>
<ol>
<li>Filemaker declares the function pointer&nbsp;<code class="brush:cpp">FMX_ExternCallProc entryPoint</code> (in&nbsp;its callback struct).</li>
<li>Filemaker examines the standard places where Filemaker users (or the Filemaker AutoUpdate Plug-In) could have placed plug-ins.</li>
<li>For every file it finds in these folders it will execute a <code class="brush:cpp">
LoadLibrary("Filename")</code>-function (on Windows) or a <code class="brush:cpp">
dlopen("Filename",mode)</code>-function, where the Filename is the name of the (presumed) plug-in file in the folder.</li>
<li>The loaded library is then used as a parameter to a function called&nbsp;<code class="brush:cpp">GetAddressProc()</code> on Windows or&nbsp;<code class="brush:cpp">dlsym()</code>
 on Mac OS X, which returns a pointer to a function of which the name 
(”FMExternCallProc”) is also supplied. On Windows, in short form:</li>
</ol>
<div><div id="highlighter_785756" class="syntaxhighlighter  cpp"><div class="toolbar"><span><a href="#" class="toolbar_item command_help help">?</a></span></div><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="cpp plain">FMX_ExternCallProc FilemakerExternCallProc = GetProcAddress(LoadLibrary(“Filename”),”FMExternCallProc”).</code></div></div></td></tr></tbody></table></div></div>
<ol start="5">
<li>If&nbsp;<code class="brush:cpp">GetProcAddress
</code> (or <code class="brush:cpp">
dllsym</code>) doesn’t find the function it will return a NULL pointer 
and Filemaker knows it is not a useable plug-in. Else Filemaker has the 
pointer to your plug-in’s function, puts it in its&nbsp;<code class="brush:cpp">struct FMX_ExternCallStruct</code> and can call it to supply the pointer to this struct.</li>
</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p>
<p></p>
	
</div>

						</div>
					
								<div class="clr"></div>
			</div>
		</div>
		<div id="footer">
			<p style="text-align:center;">
 	Van der Linden Cultural Services, Powered by <a href="http://joomla.org/" class="sgfooter" target="_blank">Joomla!</a>

	

	
	

</p>
		</div>
		</div>
	</div>
	<div id="footergrad">&nbsp;</div>

<div style="padding: 0px; border: medium none; margin: 0px; position: absolute; left: 0px; top: 0px; width: 100%; z-index: 1001; direction: ltr;" class="highslide-container"><a style="position: absolute; top: -9999px; opacity: 0.75; z-index: 1;" href="javascript:;" title="Click to cancel" class="highslide-loading">Loading...</a><div style="display: none;"></div><div style="padding: 0px; border: medium none; margin: 0px; visibility: hidden;" class="highslide-viewport highslide-viewport-size"></div><table style="padding: 0px; border: medium none; margin: 0px; visibility: hidden; position: absolute; border-collapse: collapse; width: 0px;" cellspacing="0"><tbody style="padding: 0px; border: medium none; margin: 0px;"><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll 0px 0px; height: 20px; width: 20px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll 0px -40px; height: 20px; width: 20px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll -20px 0px; height: 20px; width: 20px;"></td></tr><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll 0px -80px; height: 20px; width: 20px;"></td><td class="drop-shadow highslide-outline" style="padding: 0px; border: medium none; margin: 0px; position: relative;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll -20px -80px; height: 20px; width: 20px;"></td></tr><tr style="padding: 0px; border: medium none; margin: 0px; height: auto;"><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll 0px -20px; height: 20px; width: 20px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll 0px -60px; height: 20px; width: 20px;"></td><td style="padding: 0px; border: medium none; margin: 0px; line-height: 0; font-size: 0px; background: transparent url(&quot;http://culturalservices.nl/plugins/content/highslide/graphics/outlines/drop-shadow.png&quot;) repeat scroll -20px -20px; height: 20px; width: 20px;"></td></tr></tbody></table></div></body></html>